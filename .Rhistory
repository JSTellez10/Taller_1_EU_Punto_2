ggplot() +
geom_sf(data = upz_dens, aes(fill = dens_hab_ha), color = NA) +
scale_fill_viridis_c(option = "C", na.value = "grey90", name = "hab/m2") +
theme_minimal() + coord_sf(expand = FALSE) +
labs(title = "Censo 2018 — Densidad poblacional por manzana (Bogotá)",
subtitle = "Habitantes por M^2",
x = NULL, y = NULL)
ggplot() +
geom_sf(data = upz_dens, aes(fill = dens_hab_ha), color = "white", linewidth = 0.15) +
scale_fill_viridis_c(option = "C", na.value = "grey90", name = "hab/ha") +
coord_sf(expand = FALSE) +
theme_minimal() +
labs(
title = "Censo 2018 — Densidad poblacional por UPZ (Bogotá)",
subtitle = "Habitantes por hectárea (agregado desde manzana)",
x = NULL, y = NULL
)
manzanas_clean <- manzanas_bog |>
st_make_valid() |>
mutate(
upz     = .data[["SETU_CCDGO"]],
pob     = suppressWarnings(as.numeric(.data[["TP27_PERSO"]])),
area_m2 = suppressWarnings(as.numeric(.data[["AREA"]]))
) |>
filter(!is.na(upz), !is.na(pob), !is.na(area_m2), area_m2 > 0)
upz_dens <- manzanas_clean |>
group_by(upz) |>
summarize(
pob_tot = sum(pob, na.rm = TRUE),
area_m2 = sum(area_m2, na.rm = TRUE),
geometry = st_make_valid(st_union(geometry)),
.groups = "drop"
) |>
mutate(
area_ha     = area_m2 / 1e4,
dens_hab_ha = if_else(area_ha > 0, pob_tot / area_ha, NA_real_)
) |>
filter(!st_is_empty(geometry))
ggplot() +
geom_sf(data = upz_dens, aes(fill = dens_hab_ha), color = "white", linewidth = 0.15) +
scale_fill_viridis_c(option = "C", na.value = "grey90", name = "hab/ha") +
coord_sf(expand = FALSE) +
theme_minimal() +
labs(
title = "Censo 2018 — Densidad poblacional por UPZ (Bogotá)",
subtitle = "Habitantes por hectárea (agregado desde manzana)",
x = NULL, y = NULL
)
# 1) Limpieza mínima y tipos
manzanas_clean <- manzanas_bog |>
st_make_valid() |>
mutate(
upz     = .data[["SETU_CCDGO"]],
pob     = suppressWarnings(as.numeric(.data[["TP27_PERSO"]])),
area_m2 = suppressWarnings(as.numeric(.data[["AREA"]]))
) |>
filter(!is.na(upz), !is.na(pob), !is.na(area_m2), area_m2 > 0)
# 2) Disolver por UPZ y calcular densidad en hab/m²
upz_dens_m2 <- manzanas_clean |>
group_by(upz) |>
summarize(
pob_tot = sum(pob, na.rm = TRUE),
area_m2 = sum(area_m2, na.rm = TRUE),
geometry = st_make_valid(st_union(geometry)),
.groups = "drop"
) |>
mutate(
dens_hab_m2 = if_else(area_m2 > 0, pob_tot / area_m2, NA_real_)
) |>
filter(!st_is_empty(geometry))
# 3) Escala acotada por percentiles (para que no se “aplasten” los colores)
lims <- quantile(upz_dens_m2$dens_hab_m2, probs = c(0.02, 0.98), na.rm = TRUE)
# 4) Mapa: densidad en hab/m² por UPZ
ggplot() +
geom_sf(data = upz_dens_m2, aes(fill = dens_hab_m2), color = "white", linewidth = 0.15) +
scale_fill_viridis_c(
option = "C",
name   = "hab/m²",
limits = lims,
oob    = scales::squish,
labels = label_number(scale = 1, accuracy = 0.0001),  # ajusta precisión si lo deseas
na.value = "grey90"
) +
coord_sf(expand = FALSE) +
theme_minimal() +
labs(
title = "Censo 2018 — Densidad poblacional por UPZ (Bogotá)",
subtitle = "Habitantes por metro cuadrado (agregado desde manzana; escala acotada P2–P98)",
x = NULL, y = NULL
)
# Clean the workspace -----------------------------------------------------
rm(list=ls())
# Definir directorios -----------------------------------------------------
users <- tolower(Sys.info()[["user"]])
rutas <- list(
usuario = "C:/Users/Usuario/OneDrive - RADDAR/Documentos/Documents/Sebastian Tellez/MAESTRIA/ECONOMIA URBANA/TALLER/TALLER 1/Taller_1_EU_Punto_2/",
mora  = "C:/Users/mora/Path/To/TALLER/TALLER 1/"
)
root <- rutas[[users]]
setwd(root)
stores <- file.path(root, "stores")
scripts <- file.path(root, "scripts")
views <- file.path(root, "views")
# Load Packages -----------------------------------------------------------
#install.packages("pacman")
require("pacman")
p_load(rio,
dplyr,
ggplot2,
viridis,
forcats,
leaflet,
sf,
here,
scales
)
# Cargar datos -----------------------------------------------------------
data_input <- import("stores/dataTaller01_Amenidades.rds") %>% as_tibble()
# Limpieza y transformación -----------------------------------------------------------
# Filtramos datos sin NA en price y superficie, y sin ceros o negativos
housing_data <- data_input %>%
filter(!is.na(price), !is.na(surface_total)) %>%
filter(price > 0, surface_total > 0)
# Identificación de outliers
iqr_surface <- IQR(housing_data$surface_total, na.rm = TRUE)
housing_data <- housing_data %>%
mutate(outlier_surface = ifelse(surface_total > 4 * iqr_surface, 1, 0))
table(housing_data$outlier_surface)
# Categorización por cuantiles
q_surface <- quantile(housing_data$surface_total, na.rm = TRUE)
housing_data <- housing_data %>%
mutate(surface_q = case_when(
surface_total < q_surface[2] ~ "Q1",
surface_total < q_surface[3] ~ "Q2",
surface_total < q_surface[4] ~ "Q3",
TRUE ~ "Q4"
))
# Clasificación tipo de edifició (casa, apartamento, comercial) - Para ver detalle del codigo consultar script en carpeta "scripts"
source(file.path(scripts, "extraccion_tipo.R"))
table(housing_data$tipo)
# Creamos variable logarítmica
housing_data <- housing_data %>%
mutate(log_price = log(price),
log_surface = log(surface_total))
# Visualización descriptivan -----------------------------------------------------------
# Relación log–log entre superficie y precio
ggplot(housing_data, aes(x = log_surface, y = log_price)) +
# nube de puntos ligera
geom_point(alpha = 0.15, size = 0.6) +
# capas de densidad para ver concentraciones
stat_density_2d(aes(fill = after_stat(level)),
geom = "polygon", alpha = 0.18, contour_var = "ndensity",
show.legend = FALSE) +
scale_fill_viridis_c(option = "C", guide = "none") +
# recta de tendencia por panel
geom_smooth(method = "lm", se = FALSE, linewidth = 0.9, color = "black") +
# paneles por tipo de operación (mismos límites para comparar)
facet_wrap(~ operation, ncol = 2, scales = "fixed") +
labs(
title = "Relación log–log entre superficie y precio",
subtitle = "Paneles por operación (Venta vs. Arriendo)",
x = "Log(Superficie total)",
y = "Log(Precio)"
) +
theme_minimal(base_size = 12) +
theme(panel.grid.minor = element_blank())
# Boxplot por cuartiles de superficie
ggplot(housing_data, aes(x = surface_q, y = log_price, fill = surface_q)) +
geom_violin(trim = FALSE, width = 0.9, alpha = 0.15, color = NA) +
geom_boxplot(width = 0.55, notch = TRUE, outlier.alpha = 0.12) +
stat_summary(fun = mean, geom = "point",
shape = 21, size = 2, stroke = 0.3,
fill = "white", color = "black") +
scale_x_discrete(limits = c("Q1","Q2","Q3","Q4")) +
scale_fill_viridis(discrete = TRUE, option = "C", guide = "none") +
facet_wrap(~ operation, ncol = 2, scales = "fixed") +
labs(
title = "Distribución de precios por cuartiles de superficie",
subtitle = "Paneles por operación (Venta vs. Alquiler)",
x = "Cuartil de superficie",
y = "Log(Precio)"
) +
theme_classic(base_size = 12) +
theme(plot.title = element_text(face = "bold"),
panel.grid.minor = element_blank())
# Boxplot por tipo de propiedad
ggplot(
housing_data %>%
filter(is.finite(price)) %>%
mutate(
operation = factor(operation, levels = c("Venta","Alquiler"))
),
aes(
x = log(price),
y = fct_reorder(tipo, price, .fun = median, .desc = FALSE)
)
) +
# forma de la distribución
geom_violin(trim = FALSE, alpha = 0.15, color = NA, fill = "#6C8EBF") +
# caja (dispersión) con outliers atenuados
geom_boxplot(width = 0.55, notch = TRUE, outlier.alpha = 0.12, color = "grey20", fill = "grey90") +
# punto de la media
stat_summary(fun = mean, geom = "point",
shape = 21, size = 2.2, stroke = 0.3,
fill = "white", color = "black") +
facet_wrap(~ operation, ncol = 2, scales = "fixed") +
labs(
title = "Distribución de precios por tipo de propiedad",
subtitle = "Paneles por operación (Venta vs. Alquiler)\nViolin = forma | Boxplot = dispersión | Punto = media",
x = "Log(Precio)",
y = "Tipo de propiedad (ordenado por mediana)"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold"),
panel.grid.minor = element_blank(),
legend.position = "none"
)
# Shapefile base precios  -----------------------------------------------------------
#Pasar la base de precios a sf
housing_data_sf <- st_as_sf(housing_data, coords = c("lon", "lat"), crs = 4326)
bog_bbox_4326 <- st_as_text(st_as_sfc(
st_bbox(c(xmin = -74.35, ymin = 4.45, xmax = -73.95, ymax = 4.95), crs = 4326)
))
manzanas_bog <- st_read(
dsn = here("stores", "MGN_NivelManzana_Integrado_CNPV", "MGN_ANM_MANZANA.shp"),
wkt_filter = bog_bbox_4326, quiet = TRUE
) |>
st_transform(4326) |>
st_make_valid()
manzanas_bog <- manzanas_bog |> filter(MPIO_CDPMP == "11001")
ggplot() +
geom_sf(data = manzanas_bog, aes(fill = DENSIDAD), color = NA) +
scale_fill_viridis_c(option = "C", na.value = "grey90", name = "hab/m2") +
theme_minimal() + coord_sf(expand = FALSE) +
labs(title = "Censo 2018 — Densidad poblacional por manzana (Bogotá)",
subtitle = "Habitantes por M^2",
x = NULL, y = NULL)
# 1) Limpieza de campos y filtrado básico
m0 <- manzanas_bog |>
mutate(
upz     = str_trim(as.character(SETU_CCDGO)),
pob     = suppressWarnings(as.numeric(TP27_PERSO)),
area_m2 = suppressWarnings(as.numeric(AREA))
) |>
filter(!is.na(upz), upz != "", !is.na(pob), !is.na(area_m2), area_m2 > 0)
if (nrow(m0) == 0) stop("No hay manzanas con UPZ/población/área válidas.")
# 2) Asegurar geometrías válidas y disolver por UPZ
#    (buffer(0) + make_valid reduce fallas al unir polígonos)
m0 <- st_make_valid(m0)
m0 <- st_buffer(m0, 0)
saveRDS(
manzanas_bog,
file = file.path(stores, "manzanas_bogota_cnpv2018.rds"),
compress = "xz"
)
barrios <- st_read(here("stores/Bogota/SECTOR.shp"), quiet = TRUE)
barrios <- st_transform(barrios, crs = 4326)
barrios <- st_make_valid(barrios)  # sanea geometrías
housing_data_sf <- st_as_sf(housing_data, coords = c("lon", "lat"), crs = 4326)
idx   <- st_intersects(barrios, housing_data_sf)  # índices de puntos por polígono
n_obs <- lengths(idx)
barrios_con_datos <- barrios[n_obs > 0, ] |>
mutate(n_obs = n_obs[n_obs > 0])
housing_data_sf <- housing_data_sf %>%
mutate(price_mill = price / 1e6)
lims_by_op <- housing_data_sf %>%
st_drop_geometry() %>%                       # solo atributos
group_by(operation) %>%
summarize(lo = quantile(price_mill, 0.01, na.rm = TRUE),
hi = quantile(price_mill, 0.99, na.rm = TRUE),
.groups = "drop") %>%
split(.$operation)                           # lista nombrada por operación
# Función de mapa con límites por operación
plot_mapa_tipo_op <- function(tipo_sel, oper_sel) {
df_pts <- housing_data_sf %>%
filter(tipo == tipo_sel, operation == oper_sel)
lims_op <- with(lims_by_op[[oper_sel]], c(lo, hi))
ggplot() +
geom_sf(data = barrios_con_datos, fill = "white", color = "black", linewidth = 0.2) +
geom_sf(data = df_pts, aes(color = price_mill), size = 0.8, alpha = 0.7, na.rm = TRUE) +
scale_color_viridis_c(
option = "plasma",
name   = "Precio (millones)",
limits = lims_op,             # límites específicos de la operación
oob    = scales::squish
) +
coord_sf(expand = FALSE) +
theme_minimal() +
labs(
title    = "Precios de vivienda en Bogotá",
subtitle = paste0("Tipo: ", tipo_sel, " | Operación: ", oper_sel,
" | Escala en millones (P1–P99 por operación)"),
x = NULL, y = NULL
)
}
mapa_casa_alquiler <- plot_mapa_tipo_op("Casa", "Alquiler")
mapa_casa_venta    <- plot_mapa_tipo_op("Casa", "Venta")
mapa_apto_alquiler <- plot_mapa_tipo_op("Apartamento/Apartaestudio", "Alquiler")
mapa_apto_venta    <- plot_mapa_tipo_op("Apartamento/Apartaestudio", "Venta")
mapa_com_alquiler  <- plot_mapa_tipo_op("Comercial", "Alquiler")
mapa_com_venta     <- plot_mapa_tipo_op("Comercial", "Venta")
mapa_casa_alquiler
##########################################################
# Taller 1 - Económia Urbana
# Ejercicio 2
# author: Eimmy Nicoll Tovar Escobar y Juan Sebastian Tellez Melo
##########################################################
# Clean the workspace -----------------------------------------------------
rm(list=ls())
# Definir directorios -----------------------------------------------------
users <- tolower(Sys.info()[["user"]])
rutas <- list(
usuario = "C:/Users/Usuario/OneDrive - RADDAR/Documentos/Documents/Sebastian Tellez/MAESTRIA/ECONOMIA URBANA/TALLER/TALLER 1/Taller_1_EU_Punto_2/",
mora  = "C:/Users/mora/Path/To/TALLER/TALLER 1/"
)
root <- rutas[[users]]
setwd(root)
stores <- file.path(root, "stores")
scripts <- file.path(root, "scripts")
views <- file.path(root, "views")
# Load Packages -----------------------------------------------------------
#install.packages("pacman")
require("pacman")
p_load(rio,
dplyr,
ggplot2,
viridis,
forcats,
leaflet,
sf,
here,
scales
)
# Cargar datos -----------------------------------------------------------
data_input <- import("stores/dataTaller01_Amenidades.rds") %>% as_tibble()
# Limpieza y transformación -----------------------------------------------------------
# Filtramos datos sin NA en price y superficie, y sin ceros o negativos
housing_data <- data_input %>%
filter(!is.na(price), !is.na(surface_total)) %>%
filter(price > 0, surface_total > 0)
# Identificación de outliers
iqr_surface <- IQR(housing_data$surface_total, na.rm = TRUE)
housing_data <- housing_data %>%
mutate(outlier_surface = ifelse(surface_total > 4 * iqr_surface, 1, 0))
table(housing_data$outlier_surface)
# Categorización por cuantiles
q_surface <- quantile(housing_data$surface_total, na.rm = TRUE)
housing_data <- housing_data %>%
mutate(surface_q = case_when(
surface_total < q_surface[2] ~ "Q1",
surface_total < q_surface[3] ~ "Q2",
surface_total < q_surface[4] ~ "Q3",
TRUE ~ "Q4"
))
# Clasificación tipo de edifició (casa, apartamento, comercial) - Para ver detalle del codigo consultar script en carpeta "scripts"
source(file.path(scripts, "extraccion_tipo.R"))
table(housing_data$tipo)
# Creamos variable logarítmica
housing_data <- housing_data %>%
mutate(log_price = log(price),
log_surface = log(surface_total))
# Visualización descriptivan -----------------------------------------------------------
# Relación log–log entre superficie y precio
ggplot(housing_data, aes(x = log_surface, y = log_price)) +
# nube de puntos ligera
geom_point(alpha = 0.15, size = 0.6) +
# capas de densidad para ver concentraciones
stat_density_2d(aes(fill = after_stat(level)),
geom = "polygon", alpha = 0.18, contour_var = "ndensity",
show.legend = FALSE) +
scale_fill_viridis_c(option = "C", guide = "none") +
# recta de tendencia por panel
geom_smooth(method = "lm", se = FALSE, linewidth = 0.9, color = "black") +
# paneles por tipo de operación (mismos límites para comparar)
facet_wrap(~ operation, ncol = 2, scales = "fixed") +
labs(
title = "Relación log–log entre superficie y precio",
subtitle = "Paneles por operación (Venta vs. Arriendo)",
x = "Log(Superficie total)",
y = "Log(Precio)"
) +
theme_minimal(base_size = 12) +
theme(panel.grid.minor = element_blank())
# Boxplot por cuartiles de superficie
ggplot(housing_data, aes(x = surface_q, y = log_price, fill = surface_q)) +
geom_violin(trim = FALSE, width = 0.9, alpha = 0.15, color = NA) +
geom_boxplot(width = 0.55, notch = TRUE, outlier.alpha = 0.12) +
stat_summary(fun = mean, geom = "point",
shape = 21, size = 2, stroke = 0.3,
fill = "white", color = "black") +
scale_x_discrete(limits = c("Q1","Q2","Q3","Q4")) +
scale_fill_viridis(discrete = TRUE, option = "C", guide = "none") +
facet_wrap(~ operation, ncol = 2, scales = "fixed") +
labs(
title = "Distribución de precios por cuartiles de superficie",
subtitle = "Paneles por operación (Venta vs. Alquiler)",
x = "Cuartil de superficie",
y = "Log(Precio)"
) +
theme_classic(base_size = 12) +
theme(plot.title = element_text(face = "bold"),
panel.grid.minor = element_blank())
# Boxplot por tipo de propiedad
ggplot(
housing_data %>%
filter(is.finite(price)) %>%
mutate(
operation = factor(operation, levels = c("Venta","Alquiler"))
),
aes(
x = log(price),
y = fct_reorder(tipo, price, .fun = median, .desc = FALSE)
)
) +
# forma de la distribución
geom_violin(trim = FALSE, alpha = 0.15, color = NA, fill = "#6C8EBF") +
# caja (dispersión) con outliers atenuados
geom_boxplot(width = 0.55, notch = TRUE, outlier.alpha = 0.12, color = "grey20", fill = "grey90") +
# punto de la media
stat_summary(fun = mean, geom = "point",
shape = 21, size = 2.2, stroke = 0.3,
fill = "white", color = "black") +
facet_wrap(~ operation, ncol = 2, scales = "fixed") +
labs(
title = "Distribución de precios por tipo de propiedad",
subtitle = "Paneles por operación (Venta vs. Alquiler)\nViolin = forma | Boxplot = dispersión | Punto = media",
x = "Log(Precio)",
y = "Tipo de propiedad (ordenado por mediana)"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold"),
panel.grid.minor = element_blank(),
legend.position = "none"
)
# Shapefile base precios  -----------------------------------------------------------
#Pasar la base de precios a sf
housing_data_sf <- st_as_sf(housing_data, coords = c("lon", "lat"), crs = 4326)
# Censo Nacional de Población 2018 ---------------------------------------
#solo para cargar los archivos, la base resultante se adjunta.
#pra descargar archivos del censo: https://microdatos.dane.gov.co/index.php/catalog/643/related-materials
# BBox de Bogotá (para leer solo esa zona y acelerar)
#bog_bbox_4326 <- st_as_text(st_as_sfc(
#st_bbox(c(xmin = -74.35, ymin = 4.45, xmax = -73.95, ymax = 4.95), crs = 4326)
#))
# Leer shapefile recortando al BBox, poner en 4326 y sanear
#manzanas_bog <- st_read(
#dsn = here("stores", "MGN_NivelManzana_Integrado_CNPV", "MGN_ANM_MANZANA.shp"),
#wkt_filter = bog_bbox_4326, quiet = TRUE
#) |>
#st_transform(4326) |>
#st_make_valid()
# Filtrar Bogotá (MPIO_CDPMP es character)
#manzanas_bog <- manzanas_bog |> filter(MPIO_CDPMP == "11001")
#guardar base del censo para Bogotá nivel manzana
#saveRDS(
#manzanas_bog,
#file = file.path(stores, "manzanas_bogota_cnpv2018.rds"),
#compress = "xz"
#)
#cargar base censo para Bogotá
manzanas_bog <- readRDS(file.path(stores, "manzanas_bogota_cnpv2018.rds"))
ggplot() +
geom_sf(data = manzanas_bog, aes(fill = DENSIDAD), color = NA) +
scale_fill_viridis_c(option = "C", na.value = "grey90", name = "hab/m2") +
theme_minimal() + coord_sf(expand = FALSE) +
labs(title = "Censo 2018 — Densidad poblacional por manzana (Bogotá)",
subtitle = "Habitantes por M^2",
x = NULL, y = NULL)
stats_dens <- manzanas_bog |>
st_drop_geometry() |>
summarize(
n        = n(),
min      = min(DENSIDAD, na.rm = TRUE),
q1       = quantile(DENSIDAD, 0.25, na.rm = TRUE),
median   = median(DENSIDAD, na.rm = TRUE),
mean     = mean(DENSIDAD, na.rm = TRUE),
q3       = quantile(DENSIDAD, 0.75, na.rm = TRUE),
p90      = quantile(DENSIDAD, 0.90, na.rm = TRUE),
p95      = quantile(DENSIDAD, 0.95, na.rm = TRUE),
max      = max(DENSIDAD, na.rm = TRUE),
sd       = sd(DENSIDAD, na.rm = TRUE)
)
stats_dens
ggplot(st_drop_geometry(manzanas_bog), aes(x = DENSIDAD)) +
geom_histogram(bins = 40, alpha = 0.7) +
geom_density(linewidth = 0.9) +
scale_x_continuous(labels = label_number(accuracy = 0.0001)) +
labs(
title = "Distribución de la densidad poblacional (hab/m²)",
x = "Densidad (hab/m²)",
y = "Frecuencia"
) +
theme_minimal()
lims <- quantile(manzanas_bog$DENSIDAD, probs = c(0.02, 0.98), na.rm = TRUE)
ggplot() +
geom_sf(data = manzanas_bog, aes(fill = DENSIDAD), color = NA) +
scale_fill_viridis_c(
option = "C",
name   = "hab/m²",
limits = lims,            # escala acotada P2–P98
oob    = scales::squish   # valores fuera de rango se “aplastan” al borde
) +
coord_sf(expand = FALSE) +
theme_minimal() +
labs(
title = "Censo 2018 — Densidad poblacional por manzana (Bogotá)",
subtitle = "Habitantes por m² (escala acotada P2–P98)",
x = NULL, y = NULL
)
rm(list=ls())
